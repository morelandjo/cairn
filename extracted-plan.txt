
FEDERATED COMMUNICATION PLATFORM
Step-by-Step Implementation Plan

A privacy-first, decentralized alternative to Discord
Self-hosted • End-to-End Encrypted • Federated • Open Source

Project Overview
This document outlines the complete implementation plan for a federated, privacy-first communication platform. The platform provides Discord-like functionality (text channels, voice chat, moderation, roles) while ensuring that every node is independently hosted, no central authority exists, and private communications are end-to-end encrypted by default.

Core Principles
The server is untrusted by design. Even a malicious node operator should only see public channel content and encrypted blobs for everything private.
No centralization. Every node is independently hosted and operated. No dependency on any cloud provider, though operators may choose to use one.
Privacy as a protocol requirement, not a feature. E2E encryption for DMs and private channels is mandatory and cannot be disabled by node operators.
Federation with sovereignty. Each node controls its own moderation, data retention, and federation policies. Nodes can defederate from others.
Metadata minimization. The system collects and transmits only the minimum metadata necessary for operation.

Technology Stack Summary
Component
Technology
Server Runtime
Elixir / Phoenix Framework (BEAM VM)
Real-time Messaging
Phoenix Channels (WebSockets)
Federation Protocol
ActivityPub (extended with custom vocabulary)
Database
PostgreSQL (structured data)
Search
Meilisearch (message search, self-hosted)
Cache / Ephemeral State
Redis (presence, typing indicators)
Voice / Video
WebRTC with mediasoup SFU (Node.js sidecar)
E2E Encryption
MLS Protocol (group), X3DH + Double Ratchet (DMs)
Password Hashing
Argon2id
Node-to-Node Auth
Mutual TLS (mTLS) + HTTP Signatures
Storage Backends
Local filesystem (default), S3-compatible API (optional)
Web Client
React (TypeScript)
Desktop Client
Tauri (Rust + Web UI)
Mobile Client
React Native / Expo

Phase 0: Prerequisites & Project Setup
Before writing any application code, establish the project infrastructure, development environment, and foundational decisions that every subsequent phase depends on.

0.1 — Development Environment
Install Elixir (latest stable) and Erlang/OTP via asdf or mise version manager. Pin versions in .tool-versions.
Install PostgreSQL 16+, Redis 7+, and Meilisearch. Use Docker Compose for local development so every contributor gets an identical environment.
Install Node.js 20 LTS (needed for mediasoup SFU sidecar and the web client toolchain).
Install Rust stable toolchain (needed for Tauri desktop builds and any NIFs you write for crypto).
Set up a monorepo structure. Recommended layout:

Directory
Purpose
Language
server/
Phoenix application (API, federation, business logic)
Elixir
sfu/
mediasoup SFU sidecar for voice/video
Node.js
client/web/
React SPA web client
TypeScript
client/desktop/
Tauri shell wrapping web client
Rust + TS
client/mobile/
React Native mobile app
TypeScript
proto/
Shared protocol definitions, crypto utils
Mixed
docs/
Architecture docs, protocol spec, API reference
Markdown
deploy/
Docker, Compose, Ansible playbooks
YAML

0.2 — Protocol Specification (Write This First)
Before writing code, draft the protocol specification document. This is the contract that all clients and servers implement against. It should define:
The ActivityPub extensions: custom object types for Server (community), Channel, Message, Role, Reaction, and how they map to AS2 vocabulary.
The federation handshake: how two nodes discover each other, verify identity via mTLS, and establish a subscription for channel updates.
The message envelope format: what metadata is included (author, timestamp, channel, signature) and what is explicitly excluded (IP, device info, client version).
The E2E encryption contract: how key bundles are published, how MLS group sessions are initiated, and how encrypted payloads are structured.
The privacy manifest schema: a JSON document each node publishes describing its policies (logging, retention, federation rules).
This spec does not need to be perfect on day one. It will evolve. But having a written reference prevents you from making incompatible decisions between server and client.

0.3 — CI/CD and Quality Gates
Set up GitHub Actions (or similar) with: Elixir tests (mix test), TypeScript lint + tests, Rust clippy + tests for Tauri.
Enforce code formatting: mix format for Elixir, prettier for TypeScript, rustfmt for Rust.
Add Dialyzer for Elixir type checking. The BEAM is dynamically typed; Dialyzer catches contract violations early.
Set up a staging environment with two federated nodes (Docker Compose) for integration testing from Phase 2 onward.

Phase 1: Single-Node Server with E2E Encrypted DMs
The goal of this phase is a working single-node server with authenticated users, text channels, real-time messaging, and end-to-end encrypted direct messages. No federation yet. This is the foundation everything else builds on.

1.1 — Phoenix Project Scaffolding
Generate a new Phoenix project: mix phx.new server --no-html --no-assets (API only, no server-rendered views).
Configure Ecto for PostgreSQL. Design the initial schema:

Table
Key Fields
Notes
users
id (UUID), username, display_name, password_hash, identity_public_key, signed_prekeys, created_at
Argon2id for password_hash. Identity key is the user's long-term public key for E2E encryption.
channels
id, name, type (public/private/dm), description, created_at
DMs are channels with type=dm and exactly 2 members.
channel_members
channel_id, user_id, role, joined_at
Junction table. Role is one of: owner, moderator, member.
messages
id, channel_id, author_id, content, encrypted_content, nonce, timestamp, edited_at
For public channels, content is plaintext. For DMs/private, content is null and encrypted_content holds the ciphertext.
roles
id, name, permissions (JSONB), priority
Permissions stored as JSONB bitfield map.

Run mix ecto.migrate. Write seeds for a default admin user and a #general channel.

1.2 — Authentication System
Implement registration endpoint: POST /api/v1/auth/register. Accept username and password (no email required by default). Hash password with Argon2id (use the comeonin / argon2_elixir package).
Implement login endpoint: POST /api/v1/auth/login. Return a JWT access token (short-lived, 15 min) and a refresh token (long-lived, stored server-side with rotation).
Implement token refresh: POST /api/v1/auth/refresh.
Add TOTP 2FA support: POST /api/v1/auth/2fa/enable, /verify, /disable. Use the nimble_totp library.
Add WebAuthn/passkey support as an alternative 2FA method. Use the wax library for Elixir.
Build auth plug (middleware) that validates JWT on every API request and WebSocket connection.

1.3 — Real-Time Messaging via Phoenix Channels
Create a UserSocket that authenticates via the JWT token passed as a connection param.
Create a ChannelChannel (Phoenix Channel for chat channels). Users join channel:UUID. Server verifies membership before allowing join.
Implement message broadcasting: when a user pushes a new_msg event, the server persists it to PostgreSQL, then broadcasts to all connected members of that channel.
Implement presence tracking using Phoenix.Presence. This gives you online/offline/idle status for free, with conflict resolution across distributed nodes later.
Implement typing indicators: ephemeral events (typing_start, typing_stop) broadcast to channel members but not persisted.
Add message editing and deletion. Edited messages retain a history. Deleted messages are soft-deleted (content cleared, tombstone remains for sync).

1.4 — E2E Encryption for DMs
This is the most critical piece to get right early. The encryption happens entirely client-side; the server only stores and relays ciphertext.
Key generation (client-side): on first login, the client generates a long-term Ed25519 identity key pair, a medium-term X25519 signed prekey, and a batch of one-time X25519 prekeys. The private keys are stored in the client's secure storage (browser IndexedDB with encryption, OS keychain for desktop/mobile). The public keys are uploaded to the server.
Server key bundle endpoint: GET /api/v1/users/:id/keys returns the user's identity public key, signed prekey, and one available one-time prekey (consumed on retrieval).
Session initiation (X3DH): when User A wants to DM User B, the client fetches B's key bundle, performs the X3DH key agreement, and sends an initial message containing the ephemeral public key and ciphertext. The server cannot decrypt this.
Ongoing messages (Double Ratchet): after the initial handshake, both clients maintain a Double Ratchet session for forward secrecy. Each message uses a unique key derived from the ratchet state. Use the libsodium primitives (XChaCha20-Poly1305 for symmetric encryption, X25519 for DH).
Implement the crypto library as a shared TypeScript package in proto/ that both web and mobile clients import. Use the libsodium.js (sodium-plus) library. Do not roll your own crypto primitives.
Write extensive tests for the crypto layer: key exchange, message encryption/decryption, ratchet advancement, out-of-order message handling, and session recovery.

1.5 — Storage Backend Abstraction
Define an Elixir behaviour StorageBackend with callbacks: put(key, data), get(key), delete(key), list(prefix), exists?(key).
Implement LocalFileBackend: stores files in a configurable directory on disk. Files are named by SHA-256 content hash. Metadata (original filename, mime type, uploader, timestamp) stored in PostgreSQL.
Implement S3CompatibleBackend: uses the ex_aws library to talk to any S3-compatible API (MinIO, Garage, SeaweedFS, or actual S3 if the operator chooses).
Add configuration in config/runtime.exs so the operator sets the backend via environment variable: STORAGE_BACKEND=local or STORAGE_BACKEND=s3 with corresponding S3_ENDPOINT, S3_BUCKET, S3_ACCESS_KEY, S3_SECRET_KEY.
Implement file upload endpoint: POST /api/v1/upload. Multipart form data. Server hashes the content, stores via the active backend, returns the content hash as the file ID.
For files attached to E2E encrypted channels, the client encrypts the file before upload. The server stores an opaque blob. The decryption key is shared within the encrypted channel message.

1.6 — Basic Web Client
Scaffold a React + TypeScript project with Vite. Install dependencies: zustand (state management), socket.io-client or phoenix.js (WebSocket client), sodium-plus (crypto), react-router.
Build the auth flow: registration, login, 2FA prompt if enabled. Store JWT in memory (not localStorage for security); use the refresh token flow for persistence.
Build the main layout: sidebar with channel list, main message area, member list. Keep it functional first, style later.
Implement real-time messaging: connect to Phoenix Channel, render incoming messages, send new messages. Show presence (online/offline dots) and typing indicators.
Implement the E2E encryption flow for DMs: key generation on first use, key bundle fetching, X3DH handshake, Double Ratchet messaging. The UI should show a lock icon for encrypted conversations and allow users to verify each other's safety numbers.
Implement file upload with drag-and-drop. For encrypted channels, encrypt client-side before uploading.

Phase 1 Deliverable
A working single-node chat application where users can register (no email required), create/join channels, send real-time messages, and have fully E2E encrypted DMs. The server never sees plaintext DM content. Files are stored on the local filesystem by default with S3 as an option.

Phase 2: Federation Protocol
This phase makes nodes aware of each other. Users on Node A can join channels on Node B, and messages flow between them. This is the hardest protocol design work in the project.

2.1 — Node Identity & Discovery
Each node generates a TLS certificate (self-signed or via Let's Encrypt) and an Ed25519 signing key pair on first boot. The public key becomes the node's identity.
Implement a .well-known/federation endpoint that returns the node's public key, supported protocol version, and the privacy manifest (JSON document describing logging, retention, and moderation policies).
Implement node registration: an operator adds a remote node by URL. The server fetches .well-known/federation, verifies TLS, stores the remote node's public key, and initiates an mTLS handshake.
Implement the WebFinger protocol (RFC 7033) for user discovery: GET /.well-known/webfinger?resource=acct:username@node.example.com returns the user's ActivityPub actor URL.

2.2 — ActivityPub Implementation
Implement the ActivityPub inbox (POST /inbox) and outbox (GET /users/:id/outbox) endpoints per the W3C spec.
Define custom ActivityPub object types that extend the standard vocabulary: FederatedServer (community), FederatedChannel, FederatedMessage, FederatedReaction. Document these in the protocol spec.
Implement the Follow/Accept flow for channel subscriptions: when a remote user wants to join a channel, their home node sends a Follow activity to the hosting node. The hosting node responds with Accept (or Reject based on permissions).
Implement message federation: when a message is posted to a channel with remote subscribers, the hosting node wraps it in a Create activity and POSTs it to each subscribed node's inbox. Use HTTP Signatures (draft-cavage-http-signatures) for request authentication.
Implement remote user identity verification: when a federated message arrives, the receiving node verifies the HTTP Signature against the sending node's known public key. Reject unsigned or improperly signed requests.

2.3 — Federated Message Delivery & Consistency
Implement a delivery queue using Oban (Elixir job processing library). Federated messages are enqueued and delivered asynchronously with retries. This handles temporary node outages gracefully.
Assign each message a Hybrid Logical Clock (HLC) timestamp that combines wall clock time with a logical counter. This provides causal ordering across nodes without requiring synchronized clocks.
Implement edit and delete propagation: when a message is edited or deleted on the hosting node, send Update or Delete activities to all subscribed nodes. Remote nodes must apply these within a configurable window (e.g., 48 hours for edits, immediate for deletes).
Implement the ephemeral message TTL: messages with a TTL are delivered with the expiration time in the activity. All nodes (local and remote) must hard-delete the message after the TTL expires. Run a periodic Oban job to sweep expired messages.

2.4 — Metadata Minimization in Federation
Strip all non-essential metadata from federated activities: no IP addresses, device info, client version, or read receipts cross federation boundaries.
The federated message envelope contains only: message ID, author (username@node), channel ID, content (plaintext for public, ciphertext for encrypted), timestamp (HLC), and the cryptographic signature.
Implement opt-in read receipts: disabled across federation by default. Users on the same node can opt into read receipts locally.

2.5 — Defederation & Moderation
Implement node-level blocking (defederation): an operator can block a remote node, which immediately stops all message delivery and removes cached remote content.
Implement the privacy manifest validation: when federating with a new node, compare its published privacy manifest against configurable minimum requirements. Optionally auto-reject nodes that don't meet the bar (e.g., nodes that log IPs by default).
Build an admin dashboard (web UI) for node operators: view federated nodes, their privacy manifests, block/unblock nodes, view federation delivery queue health.

2.6 — Update Web Client for Federation
Display federated user identities as username@node in the UI. Local users show just their username.
Show the remote node's privacy manifest when a user is about to join a federated channel (similar to a privacy policy prompt).
Handle federation-specific UX: message delivery latency indicators, remote node offline warnings, and defederation notifications.

Phase 2 Deliverable
Two or more independently hosted nodes that can discover each other, verify identity via mTLS, and federate channels and messages. Remote users can join channels across nodes. Messages, edits, and deletions propagate reliably. Metadata is minimized at federation boundaries. Node operators can defederate from bad actors.

Phase 3: Moderation, Roles & Public Channels
With federation working, this phase builds out the community management tools that make the platform usable for real communities.

3.1 — Permissions System
Design a role-based permission system inspired by Discord's model: each role has a set of permission flags (send_messages, manage_channels, kick_members, ban_members, manage_roles, etc.) stored as a JSONB map.
Permissions are evaluated as: base permissions (everyone role) → additive from assigned roles (highest priority wins) → channel-level overrides. Implement this as a pure function that takes a user's roles and channel overrides and returns the effective permission set.
Implement role CRUD endpoints: POST/PUT/DELETE /api/v1/servers/:id/roles. Only users with manage_roles permission can modify roles.
Implement channel-level permission overrides: per-role and per-user overrides that can grant or deny specific permissions within a channel.

3.2 — Moderation Tools
Implement user muting (server-wide and per-channel) with configurable duration. Muted users can read but not send messages.
Implement user kicking and banning. Bans can be temporary (with expiration) or permanent. Banned users cannot rejoin via federation either.
Implement a moderation log: every moderation action (mute, kick, ban, role change, channel edit) is recorded with the moderator, target, action, reason, and timestamp. Visible to users with the appropriate permission.
Implement message reporting: users can flag messages for moderator review. Reports go into a queue visible to moderators.
Implement slow mode: configurable per-channel rate limit on message sending (e.g., one message per 30 seconds).

3.3 — Channel Categories & Organization
Implement channel categories (folders): channels can be grouped under named categories with their own permission overrides.
Implement channel ordering: drag-and-drop reordering persisted as a position integer.
Implement channel topics: a short description shown at the top of the channel.
Implement pinned messages: moderators can pin messages that appear in a dedicated panel.

3.4 — Message Features
Implement message threads (replies): messages can be replies to other messages, displayed as threads in the UI.
Implement reactions: emoji reactions on messages. Use Unicode emoji, no custom emoji yet.
Implement message search via Meilisearch: index public channel messages for full-text search. Encrypted messages are not indexed (by design; the server cannot read them).
Implement message history pagination: GET /api/v1/channels/:id/messages?before=timestamp&limit=50 for infinite scroll.

Phase 3 Deliverable
A full-featured community platform with roles, permissions, moderation tools, organized channels, threads, reactions, and search. This is the point where the platform is genuinely usable as a Discord replacement for community management.

Phase 4: Voice & Video Chat
Voice is the most technically demanding feature. This phase adds real-time voice and video using WebRTC with a Selective Forwarding Unit (SFU) architecture.

4.1 — mediasoup SFU Setup
Set up the mediasoup Node.js sidecar in the sfu/ directory. mediasoup runs as a separate process that the Phoenix server communicates with via a local API (HTTP or Unix socket).
Implement a Worker/Router/Transport architecture: each voice channel gets a mediasoup Router. Each participant creates a WebRTC Transport (one for sending, one for receiving).
Configure mediasoup with Opus codec for audio (mandatory) and VP8/VP9 for video (optional). Set RTP capabilities to prioritize low latency over quality.
Implement TURN server integration: bundle coturn or recommend it in deployment docs. Many users will be behind NATs; TURN relay is essential for reliable WebRTC connectivity.

4.2 — Signaling via Phoenix Channels
Create a VoiceChannel Phoenix Channel (voice:channel_uuid). Users join this channel to initiate voice.
Implement the signaling flow: client joins → server creates a mediasoup Transport → server sends transport parameters to client → client creates local RTCPeerConnection → client connects transport → client produces audio → server creates a Producer → other clients create Consumers for each Producer.
Implement presence for voice channels: show who is in the voice channel, who is speaking (via audio level events from mediasoup), who is muted.
Implement server-side mute and deafen: moderators can mute or disconnect users from voice.

4.3 — Voice for Federated Users
Federated users connect directly to the hosting node's SFU. The signaling passes through federation (the remote user's home node proxies signaling events), but the actual audio/video stream goes directly from the remote client to the hosting SFU.
This means the hosting node handles all voice processing. Document this clearly: voice quality depends on the hosting node's bandwidth and proximity to participants.
Implement voice channel capacity limits: configurable per channel, with a sensible default (e.g., 25 participants) to prevent overloading the SFU.

4.4 — Web Client Voice UI
Add a voice connection panel: join/leave voice channel button, self-mute and self-deafen controls, active speakers display.
Implement echo cancellation, noise suppression, and automatic gain control using the browser's built-in WebRTC audio processing constraints.
Add a voice connection quality indicator: show latency, packet loss, and codec info.
Add push-to-talk as an option alongside voice activity detection.

Phase 4 Deliverable
Working voice chat in channels with support for federated participants. Audio is encrypted via DTLS-SRTP (client-to-SFU). The SFU can see unencrypted audio at this stage; E2E voice encryption comes in Phase 6.

Phase 5: Desktop & Mobile Clients
With the web client feature-complete, this phase extends to native platforms using shared code.

5.1 — Desktop App (Tauri)
Set up the Tauri project in client/desktop/. Tauri wraps the web client in a native window using the OS webview (WebKit on macOS, WebView2 on Windows, WebKitGTK on Linux). This means you ship a ~10MB binary instead of a ~200MB Electron app.
Implement native features via Tauri's Rust backend: system tray icon with unread count, native desktop notifications (not browser notifications), global keyboard shortcuts (e.g., push-to-talk), auto-start on login.
Implement secure key storage: use the OS keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service) to store E2E encryption private keys instead of browser storage.
Implement auto-update: Tauri has a built-in updater that checks a configured URL for new versions. Set up a release pipeline that builds for all three platforms (macOS, Windows, Linux) and publishes update manifests.
Test WebRTC voice in the Tauri webview. WebView2 (Windows) and WebKit (macOS) support WebRTC natively. WebKitGTK on Linux may require additional configuration; document any quirks.

5.2 — Mobile App (React Native)
Set up the React Native project in client/mobile/ using Expo. Expo simplifies the build pipeline, especially for developers who don't have extensive native iOS/Android experience.
Extract shared business logic from the web client into a shared package: API client, state management (zustand stores), message formatting, encryption utilities. Import this package in both web and mobile.
Rebuild the UI components in React Native. The layout is similar to the web client but adapted for mobile: tab-based navigation (channels, DMs, settings), swipe gestures, pull-to-refresh.
Implement push notifications using Expo's push notification service or a self-hosted alternative like ntfy (to avoid dependency on Google FCM / Apple APNS directly, though the operator can configure these). The notification payload should contain only a channel ID and message count, never message content (privacy).
Implement voice using react-native-webrtc. Test on both iOS and Android simulators and physical devices. Voice over cellular networks is particularly latency-sensitive; test and tune.
Implement secure key storage using expo-secure-store, which wraps the OS keychain on both platforms.
Implement background message sync: when the app is backgrounded, use a background fetch task to sync unread message counts (not content) so badge counts are accurate.

Phase 5 Deliverable
Native desktop apps for macOS, Windows, and Linux (Tauri) and mobile apps for iOS and Android (React Native). All share the core business logic and encryption library with the web client. Users get native notifications, system tray integration, secure key storage, and voice on all platforms.

Phase 6: Advanced Encryption & Hardening
This phase elevates the platform's security from good to exceptional. It addresses the remaining gaps: E2E encrypted group channels, E2E encrypted voice, and overall security hardening.

6.1 — MLS for Group E2E Encryption
Implement the MLS (Messaging Layer Security, RFC 9420) protocol for E2E encrypted group channels. MLS uses a tree-based key ratchet that scales efficiently: adding or removing a member is O(log n) rather than O(n) as with pairwise Signal sessions.
The MLS group state is managed client-side. The server acts only as a delivery service for MLS commit messages (member additions/removals), proposals, and encrypted application messages.
When a user marks a channel as private/encrypted, the client initiates an MLS group session. All current members' key bundles are fetched, and the group tree is constructed. Each new message is encrypted with the current group key.
Handle member joins and leaves: when a new member joins, an existing member (the inviter) sends an MLS Add proposal. When a member leaves, any remaining member sends a Remove proposal. Both trigger a key update so departed members lose access.
Implement the MLS crypto library in the shared proto/ package. Consider using the openmls Rust crate compiled to WebAssembly for cross-platform use, as MLS is complex and a battle-tested implementation reduces risk.

6.2 — E2E Encrypted Voice
Implement WebRTC Insertable Streams (also called Encoded Transforms): this API lets the client encrypt each audio/video frame before it reaches the SFU, and decrypt incoming frames after receiving them from the SFU.
The key for voice encryption is derived from the MLS group session (if the voice channel is in an encrypted group) or from a separate short-lived key exchange for ad-hoc voice calls.
The SFU forwards encrypted frames it cannot decrypt. This means SFU-level features like audio level detection may not work on encrypted streams; implement client-side audio level detection as a fallback.
Test carefully: insertable streams add latency. Benchmark the end-to-end voice latency with encryption enabled and tune the frame processing pipeline. Target sub-200ms round-trip.

6.3 — Security Hardening
Conduct a threat model review: document all trust boundaries (client/server, server/server, server/SFU, server/storage), attack surfaces, and mitigations.
Implement rate limiting on all API endpoints (using Hammer or a custom Plug). Aggressive rate limits on auth endpoints to prevent brute-force attacks.
Implement Content Security Policy headers, HSTS, and all standard web security headers on the API.
Add audit logging for sensitive operations: auth events, role changes, federation handshakes, defederation. Logs are local to the node and accessible only to the operator.
Conduct (or commission) a third-party security audit of the encryption implementation. This is non-negotiable before promoting the platform as secure for real use.
Set up a vulnerability disclosure program and publish a SECURITY.md in the repository.

6.4 — Deployment Hardening
Create official Docker images with minimal base (Alpine or distroless). The default docker-compose.yml should bring up the Phoenix server, mediasoup SFU, PostgreSQL, Redis, and Meilisearch with sane defaults.
Write Ansible playbooks for bare-metal deployment on a VPS. Target a single $5/month VPS as the minimum viable deployment.
Document disk encryption (LUKS) setup in the deployment guide. Recommend full-disk encryption for all node operators.
Implement automated backups: a mix task that exports the PostgreSQL database and file storage to an encrypted archive. Include restore documentation.

Phase 6 Deliverable
The platform now supports E2E encrypted group channels via MLS, E2E encrypted voice via insertable streams, and has undergone security hardening and (ideally) a third-party audit. Deployment is streamlined with Docker and Ansible. The platform is ready for public beta.

Key Risks & Mitigations

Risk
Impact
Mitigation
MLS complexity
High — incorrect implementation breaks group encryption
Use the openmls Rust crate (WASM) rather than implementing MLS from scratch. Extensive fuzzing and test vectors from the RFC.
Voice latency with E2E encryption
Medium — insertable streams add processing overhead
Benchmark early in Phase 6. Use hardware-accelerated crypto where available. Degrade gracefully (offer non-E2E voice as fallback with clear UI indicator).
Federation consistency edge cases
Medium — split-brain, message reordering, stale caches
Hybrid Logical Clocks for ordering. Oban retry queue for delivery. Periodic reconciliation protocol between nodes for long-running channels.
SFU resource consumption
High — voice is CPU and bandwidth intensive
Per-channel participant limits. SFU can run on a separate machine. Document resource requirements clearly.
Client key management UX
Medium — users losing keys means losing message history
Encrypted key backup/export feature. Cross-device key sync via QR code. Clear UX for key verification.
WebRTC in Tauri (Linux)
Low — WebKitGTK WebRTC support varies by distro
Test on major distros (Ubuntu, Fedora, Arch). Document workarounds. Fall back to a bundled WebRTC library if needed.

Estimated Timeline
These estimates assume a single senior developer working full-time. Adjust proportionally for team size. Phases can partially overlap once foundational work is stable.

Phase
Duration
Key Dependencies
Phase 0: Prerequisites & Setup
2–3 weeks
None
Phase 1: Single-Node + E2E DMs
8–12 weeks
Phase 0
Phase 2: Federation
8–12 weeks
Phase 1
Phase 3: Moderation & Features
6–8 weeks
Phase 1 (can start before Phase 2 is complete)
Phase 4: Voice & Video
6–10 weeks
Phase 1
Phase 5: Desktop & Mobile
6–8 weeks
Phase 1 web client stable
Phase 6: Advanced Encryption
8–12 weeks
Phases 1–4
Total
10–15 months




Next Steps
Begin with Phase 0. Set up the monorepo, write the protocol specification draft, and configure the development environment. The protocol spec is the single most important artifact; every implementation decision flows from it. Once the spec draft is reviewed, proceed to Phase 1 and start building.